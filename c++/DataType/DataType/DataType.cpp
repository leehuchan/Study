#include <iostream>

using namespace std;
// x64 : 64비트 운영 프로그램
// 한번에 64비트 (8바이트)만큼 처리
// x86 : 32비트 운영 프로그램
// 한번에 32비트 (4바이트)만큼 처리

// 레지스터: 연산에 쓰일 값을 저장
// 캐시: 가장 최근에 접근했던 주소값은 또 다시 쓰일 경우가 높다.
// 가장 빈번하게 접근했던 주소값은 또 다시 쓰일 경우가 높다.

// - 컴파일 4단계
// -- 전처리기 : 매크로, # 을 처리, 주석 삭제
// -- 컴파일러 : C++ -> 어셈블리어로 바꾼다. (고수준 -> 저수준)
// -- 어셈블러 : 어셈블리어 -> 기계어로 변환. (obj파일 생성)
// -- 링커 : 실행파일을 만들어준다. 파일결합

// 메모리 4영역
// CODE : 코드
// DATA : 전역변수(global), 정적변수(static)
// STACK : 지역변수(Local), 매개변수(Parameter, Argument), 반환주소값(Return prt)
// HEAP : 사용자가 직접 관리(사용자 메모리, 프로그래머 메모리)

// 자료형
// 관점에 따라 비트를 해석하는게 다르다.

// bit : 컴퓨터가 계산할 수 있는 가장 작은 단위
// Byte : 8bit
// 표현할 수 있는 경우의 수 : 2^8

// 정수형
// short
// 크기 : 2바이트 (-2^15 ~ 2^15 -1)... -32768 ~ 32767

// int
// 크기 : 4바이트(-2^31 ~ 2^31 -1)... 2,147,483,648 ~ 2,147,483,647

// 2의 보수법( 음의 정수를 표현하는 방법)
// 모든 비트를 바꾼다. 1의 보수법
// 1을 더한다.


// long long(__int64)
// 크기 : 8바이트(-2^63 ~ 2^63 -1)

// 부호(비트)없는 정수
// unsinged short : 2바이트 (0 ~ 2^16 -1)
// unsinged int : 4바이트 (0~ 2^32 -1)
// unsiged __int64 : 8바이트 (0 ~ 2^64 -1)

// 실수 (부동소수점)
// float : 4바이트
// (부호: 1비트) (지수부 : 8비트)(유효숫자부 : 23비트) -> 4바이트

// -> 실수도 0과1로 표현할 수 있다.

// double : 8바이트

// 부동소수점 오차 때문에 무한소수 등 실수들이 부정확할 수 있는 문제가 있음

// 문자형
// char
// 크기 : 1바이트 (-1^7 ~ 2^7 -1)
// 아스키 코드 : 영어를 1바이트
// 유니코드 
// UTF-8 (한국어, 중국어 : 3바이트)
// UTF-16 (영어 : 2바이트, 한국어/중국어 : 2바이트)
// 0.5 : 1.0 x 2^1
// [0][-1][23x0]
// [0][-1 + 127][23x0]
// 지수는 -1인데 32bit의 Bias인 127을 더해서 표기하면 126이 됨 (하나의 약속)

// 논리형
// bool : 1바이트 (컴퓨터가 처리할 수 있는 가장 작은 단위가 바이트이기 때문에 bool형은 1바이트)
// 0이면 false 그게 아니면 true

// --------------------------------
// 사용자정의 자료형
// 우리가 만드는 자료형
// struct가 있음

// 패딩바이트

// 2진법 : 0b
// 8진법 : 
// 16진법 : 0x

int main()
{
    std::cout << "Hello World!\n";

    // 정수형 오버플로우

    // 정수형 언더플로우

    int a = 3 & 4;   // a 에는 0이 들어간다.
    int b = 6 & 10;  // b 에는 2가 들어간다.

    std::cout << b << endl;

    int num = 16;

    bool powofTwo(num);
    {
        return !(num & (num - 1));
    }

    std::cout << powofTwo << endl;

    return 0;
}