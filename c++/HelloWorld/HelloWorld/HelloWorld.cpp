#include <iostream>

int main()
{
	// std: standard lib 산하의 소속
	// cout : console out
	// endl : 줄 끝

	std::cout << "HelloWorld" << std::endl;

	return 0;
}

// cpu: central processing unit
// 기억, 해석, 연산, 제어라는 4대 주요 기능을 관할하는 장치
// ram: Random Access Memory
// 사용자가 자유롭게 내용을 읽고 쓰고 지울 수 있는 기억장치.컴퓨터가 켜지는 순간부터 CPU는 연산을 하고 동작에 필요한 모든 내용이 전원이 유지되는 내내 이 기억장치에 저장된다.'주기억장치'로 분류
// 메인 메모리에 주로 사용되는 RAM은 일반적으로 전원이 차단되면 내용이 지워지는 휘발성 기억 장치

// 컴파일 4단계
// 전처리 과정 - 컴파일 과정 - 어셈블리 과정 - 링킹 과정

// 전처리 과정 전처리기를 통해 소스 코드 파일을 전처리된 소스 코드 파일로 변환하는 과정
// 주석제거, 헤더 파일 삽입 (#include 지시문을 만나면 해당하는 헤더 파일을 찾아 헤더 파일에 있는 모든 내용을 복사해서 소스 코드에 삽입한다. 즉, 헤더 파일은 컴파일에 사용되지 않고 소스 코드 파일 내에 전부 복사된다. 헤더 파일에 선언된 함수 원형은 후에 링킹 과정을 통해 실제로 함수가 정의되어 있는 오브젝트 파일(컴파일된 소스 코드 파일)과 결합한다.), 매크로 치환 및 적용 작업(#define 지시문에 정의된 매크로를 저장하고 같은 문자열을 만나면 #define 된 내용으로 치환)을 한다.

 
// 컴파일러는 세 단계(프론트엔드 - 미들엔드 - 백엔드)로 구성
// 프론트엔드에서는 언어 종속적인 부분을 처리, 소스 코드가 해당 언어로 올바르게 작성되었는지 확인(어휘/구문/의미 분석)하고 미들엔드에 넘겨주기 위한 GIMPLE 트리(소스 코드를 트리 형태로 표현한 자료 구조)를 생성
// 미들엔드에서는 아키텍쳐 비종속적인 최적화를 수행, 프론트엔드에서 넘겨받은 GIMPLE 트리를 이용해 아키텍쳐 비종속적인 최적화를 수행한 후 백엔드에서 사용하는 RTL(Register Transfer Language : 고급 언어와 어셈블리 언어의 중간 형태)를 생성
// 백엔드에서는 미들엔드에서 넘겨받은 RTL을 이용해 아키텍쳐 종속적인 최적화를 수행하고 최적화가 완료되면 어셈블리 코드를 생성

// 어셈블리 과정
// 어셈블러(Assembler)를 통해 어셈블리어 파일(*.s)을 오브젝트 파일(*.o)로 변환하는 과정
// 오브젝트 파일 : 어셈블리 코드는 이제 더 이상 사람이 알아볼 수 없는 기계어로 변환되는데 이를 오브젝트 코드

// 링킹 과정
// 링커(Linker)를 통해 오브젝트 파일(*.o)들을 묶어 실행 파일로 만드는 과정
// 이 과정에서 오브젝트 파일들과 프로그램에서 사용하는 라이브러리 파일들을 링크하여 하나의 실행 파일을 만든다.

// 1. 코드(code) 영역 2. 데이터(data) 영역 3. 스택(stack) 영역 4. 힙(heap) 영역

// 코드 영역 : 실행할 프로그램의 코드가 저장되는 영역
// 데이터 영역 : 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역 / 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸
// 스택 영역 : 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역 / 택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸 / 스택 영역에 저장되는 호출 정보를 스택 프레임
// 힙 영역 : 사용자가 직접 관리할 수 있는 '그리고 해야만 하는' 메모리 영역 / 힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제 / 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당